---
title: Serving Maps with Cloudflare Workers
---

<script>
    import StayInTouch from '../components/StayInTouch.svelte'
</script>

# {title}

##### <time datetime="2021-02-08">Feb 8, 2021</time>

<br />

Bing Maps is well known in the mapping industry for having one of the best aerial base layers. By combining orthographic aerial and satellite imagery they achieve detail that's not available with satellites alone. Bing also offer a very generous free tier for their tile service by simply signing up in the [Bing Maps Dev Center](https://www.bingmapsportal.com/) and creating an API key.

Bing Maps is great but they use their own tile system, appropriately called the [Bing Maps Tile System](https://docs.microsoft.com/en-us/bingmaps/articles/bing-maps-tile-system) (based on the [quadtree algorithm](https://en.wikipedia.org/wiki/Quadtree)). It's incompatible with apps and software that request tiles in the Open Street Map standard, [slippy map tilenames](https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames). This leads to some tricky integrations.

The function for converting a slippy tile with `x` `y` and `z` keys to a quadtree key is simple on it's face:

```js
function toQuadKey(x, y, z) {
    var index = "";
    for (var i = z; i > 0; i--) {
        var b = 0;
        var mask = 1 << (i - 1);
        if ((x & mask) !== 0) b++;
        if ((y & mask) !== 0) b += 2;
        index += b.toString();
    }
    return index;
}
```

The catch is that this function must run for every slippy tile request so it can be converted on the fly to a quadtree key. Additionally, zooming or panning around a map can fire off a ton of requests simultaneously. Cloudflare Workers were basically designed for this, massively parallel, running a simple JavaScript function to respond to an HTTP request.

Bing Maps puts one more roadblock in the way of simply doing that. On the first load of any Bing tile layer, the latest tile endpoint must be requested from their service with a [metadata API call](https://docs.microsoft.com/en-us/bingmaps/rest-services/imagery/get-imagery-metadata).

```js
fetch('https://dev.virtualearth.net/REST/v1/Imagery/Metadata/{imagerySet}?key={key}&uriScheme=https')
```

The metadata API returns a response with a list of resources, including the tile layer image URL format:

```js
{
  "resourceSets": [  
    {
      "resources": [  
        {  
          "imageUrl": "http:\/\/ecn.t3.tiles.virtualearth.net/tiles/{quadkey}.jpeg?g=471&mkt={culture}}",  
          ...
        }
      ]  
    }  
  ],  
  ...
}  
```

The metadata API has a lower rate limit than normal tile requests and loading it for every tile is not be feasible. Once again, Cloudflare Workers saves the day. Using Cloudflare KV, the latest tile endpoint can be cached so it's reused for every subsequent tile request.

The cache is keyed by imagery layer and a hash of the user's API key. By including the API key hash, the cache is bucketed by Bing Maps user:

```js
async function getCacheKey(imagerySet, key) {
    const buffer = new TextEncoder("utf-8").encode(key);
    const digest = await crypto.subtle.digest("SHA-1", buffer);
    return `${imagerySet}:${digest}`;
}

async function getTemplate(imagerySet, key) {
    const cacheKey = await getCacheKey(imagerySet, key);
    return ENDPOINTS.get(cacheKey);
}
```

In this snippet, the Cloudflare KV store is injected in to the runtime as the `ENDPOINTS` variable, and the tile template is retrieved with `ENDPOINTS.get(cacheKey)`.

All that's left is to connect the pieces together. When a request hits the Cloudflare Worker, the query string and URL path parameters are parsed:

```js
const url = new URL(request.url);
const query = [
    ...new URLSearchParams(url.search.slice(1)).entries(),
].reduce((q, [k, v]) => Object.assign(q, { [k]: v }), {});
// { key: '<Bing Maps API key>', culture: 'en-US' }

const m = url.pathname.match(/^\/(\w+)\/(\d+)\/(\d+)\/(\d+).jpg$/m);
const [path, imagerySet, z, x, y] = m;
// [path, 'Aerial', 1, 1, 1]
```

Then the tile URL template is retrieved from the cache,
the `x`, `y` and `z` parameters are converted to a quadkey, and actual tile is fetched from Bing:

```js
const template = await getTemplate(imagerySet, query.key);
const quadkey = toQuadKey(x, y, z);
const tile = await fetchTile(template, quadkey, z, query.culture);
```

Finally, the worker returns the proxied response:

```js
return new Response(tile.body, {
    status: tile.status,
    statusText: tile.statusText,
    headers: tile.headers,
});
```

The whole process is blazing fast on Cloudflare since the worker and KV store are deployed to their endpoint servers around the globe. The tile proxy is basically transparent to the end user. Even better, no user data is stored, not even logs. The user's Bing Maps API key is hashed for caching tile endpoints, but otherwise passed straight through to Bing.

The tile proxy worker is deployed here:

`https://tileproxy.wkx.workers.dev/{layer}/{z}/{x}/{y}.jpg?key={apikey}`

### Get started with the tile proxy

<div class="ml-4">

- Get started with the Bing Maps Tile Proxy here: https://tileproxy.mapgrid.org
- Add the layer to [Gaia GPS](https://www.gaiagps.com/map/?sidebar=customSource) to use from your phone
- For the curious, check out the full source code here: https://github.com/nathancahill/tile-proxy-bing

</div>

---

<StayInTouch />
